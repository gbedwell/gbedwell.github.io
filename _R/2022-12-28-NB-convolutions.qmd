---
title: Negative binomial convolutions
excerpt: Implementing exact expressions for the convolution of negative binomial distributions and alternative options.
classes: wide
format: gfm
output-file: ../_posts/2022-12-27-NB-convolutions.md
editor: source
keep-yaml: true
---

```{r, eval=FALSE}
download.file(url = "https://raw.githubusercontent.com/gbedwell/nb_convolutions/master/nbconv.R",
              destfile = "path/to/directory/nbconv.R")
```

```{r, eval=FALSE}
source("path/to/directory/nbconv.R")
```

```{r, echo=FALSE}
source("/Users/gbedwell/Documents/github/nb_convolutions/nbconv.R")
```

```{r}
mus <- c(800, 1000)
phis <- c(10, 1)
ps <- phis/(phis + mus)
qs <- 1-ps
```

```{r}
out <- nbconv(rvec = phis, pvec = ps, nterms = 100, s=1000)
```

```{r}
plot(out$s, out$pmf)
```

```{r, warnings = FALSE}
expose_stan_functions("/Users/gbedwell/Documents/github/nbconv/sum_nb_functions.stan",
                      show_compiler_warnings = FALSE)
```

```{r}
logsumexp <- function (x) {
  y = max(x)
  y + log(sum(exp(x - y)))
}
plot_approximation_densities <- function(means, phis, log_scale) {
  n_means = length(means)
  N_sums <- 1e5
  sums = numeric(N_sums)
  for(n in 1:N_sums) {
    sums[n] = sum(rnbinom(n_means, mu = means, size = phis))
  }
  
  breaks = seq(min(sums),max(sums) + 1, length.out = 30) %>% round()
  #breaks = seq(min(sums) * 0.95,max(sums)* 1.01, length.out = 30) %>% round()
  #breaks = quantile(sums, probs = seq(0, 1, length.out = 30))
  #breaks[length(breaks)] <- breaks[length(breaks)] + 1 #The intervals are left closed, so including the max value here
  
  #Prepare data for output 
  moments = numeric(length(breaks) - 1) 
  saddlepoint = numeric(length(breaks) - 1)
  empirical = numeric(length(breaks) - 1)
  
  for(b in 1:(length(breaks) - 1)) {
    #Compute the mass for each breaks[b] to breaks[b + 1] regions
    if(log_scale) {
      empirical[b] = log(mean(sums >= breaks[b] & sums < breaks[b + 1]))
    } else {
      empirical[b] = mean(sums >= breaks[b] & sums < breaks[b + 1])
    }
    
    break_length <- breaks[b + 1] - breaks[b]
    
    moments_mass <- numeric(break_length)
    saddlepoint_mass <- numeric(break_length)
    for(i in 1:break_length) {
      y <- breaks[b] + i - 1
      moments_mass[i] <- neg_binomial_sum_moments_lpmf(y, means, phis)
      saddlepoint_mass[i] <- neg_binomial_sum_saddlepoint_lpmf(y, means, phis, dummy_x_r = array(0,0))
    }
    if(any(is.na(moments_mass))) {
      stop("NA - moments")
    }
    if(any(is.na(saddlepoint_mass))) {
      stop("NA - saddlepoint")
    }
    
    if(log_scale) {
      moments[b] = logsumexp(moments_mass)
      saddlepoint[b] = logsumexp(saddlepoint_mass)
    } else {
      moments[b] = sum(exp(moments_mass))
      saddlepoint[b] = sum(exp(saddlepoint_mass))
    }
  }
  
  if(log_scale) {
    scale_name <- "log binned mass"
  } else {
    scale_name <- "binned mass"
  }
  data.frame(x = breaks[-length(breaks)], empirical, moments, saddlepoint) %>%
    gather("type","value", -x) %>%
    mutate("is_main" = if_else(type == "empirical", "yes","no")) %>%
    ggplot(aes(x = x, y = value, color = type)) + geom_line(alpha = 0.5, size = 2) +
      scale_y_continuous(scale_name) +
      scale_color_brewer(type = "qual", palette = 2)
}
means_ex1 <- c(800, 1600)
phis_ex1 <- c(10, 1)
means_ex2 <- c(50, 100, 1300, 2000)
phis_ex2 <- rep(10, length(means_ex2))
```

```{r}
plot_approximation_densities(means_ex1, phis_ex1, log_scale = FALSE)
plot_approximation_densities(means_ex1, phis_ex1, log_scale = TRUE)
```













