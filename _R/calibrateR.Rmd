---
title: calibrateR
excerpt: An R package to streamline standard laboratory calculations.
classes: wide
output:
  md_document:
    variant: gfm
    preserve_yaml: true
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = paste0(
        '/Users/gbedwell/Documents/github/gbedwell.github.io/_posts/', '2023-06-08', '-', 'calibrateR','.md'
      ),
      envir = globalenv()
    )
  })
---

```{r, include=FALSE}
date <- "2023-06-08"

base.dir <- "/Users/gbedwell/Documents/github/gbedwell.github.io/"
base.url <- "/"
dir.create(paste0("../figures/", date))
fig.path <- paste0("../figures/", date, "/")

knitr::opts_chunk$set(
  fig.asp = 5/7,
  fig.width = 7,
  dpi = 300,
  fig.align = "center",
  out.width = "80%",
  comment = "#>",
  collapse = TRUE,
  dev = "png",
  base.dir = base.dir, 
  base.url = base.url,
  fig.path = fig.path
  )
```

### Introduction

When working at the bench, there are probably certain experiments and/or calculations that you routinely do that you <i>hate</i> doing. There's no logical reason for why you feel this way. The experiment/calculation isn't hard <i>per se</i>, you just wish that you didn't have to do it <i>again</i>. 

With this feeling of frustration in mind, I decided to streamline some of these common calculations so that the heavy lifting is done behind the scenes (insofar as there is anything truly "heavy" about these calculations -- perhaps "the clicking-and-dragging" is more apt). The result, <code>calibrateR</code>, is an easy-to-use R package that contains functions to help with Gibson assembly reaction setup, protein concentration determination via colorimetric assays, size exclusion column calibration, and more. I am happy to expand <code>calibrateR</code>'s current functionalities. Please reach out with other ideas/suggestions!

<code>calibrateR</code> can be downloaded from [GitHub](https://github.com/gbedwell/calibrateR). 

### Usage

```{r}
library(calibrateR)
```

#### Colorimetric Assays

I'll start by describing the way that the package approaches colorimetric assays. For those who might be unfamiliar, colorimetric assays are a very common way of determining the concentration of analytes in solution. There are various types of colorimetric assays, but the general procedure is similar across the board. First, the user must calibrate the assay by measuring the output signal across a range of known analyte concentrations. Then, from the empirically determined relationship between analyte concentration and signal, the concentration of analyte in the experimentally relevant samples can be determined.

In the example below, I start with defined standard analyte concentrations (<code>conc</code>) and three replicates (<code>rep1-3</code>) of corresponding signal readings. Note that the signal readings are entered <i>in the same order</i> as the known concentrations.

```{r}
conc <- c(2, 1.5, 1, 0.75, 0.5, 0.25, 0.125, 0.025, 0)
rep1 <- c(2.312, 1.786, 1.273, 1.035, 0.744, 0.484, 0.351, 0.237, 0.209)
rep2 <- c(2.249, 1.739, 1.207, 0.984, 0.701, 0.455, 0.338, 0.23, 0.209)
rep3 <- c(2.282, 1.715, 1.204, 0.99, 0.712, 0.484, 0.345, 0.24, 0.208)
```

Next, I will use the <code>calibrate_colorimetric()</code> function in <code>calibrateR</code> to create a new function, here called <code>bca()</code>, to do all of the downstream data analysis for me.

```{r}
bca <- calibrate_colorimetric( conc = conc,
                               abs = c( rep1, rep2, rep3 ),
                               with.blank = TRUE,
                               nrep = 3 )
```

With the calibrated function defined, we can do one of two things. The first thing we should do is look at our fit and make sure it's reasonable. To do this, we'll use our concentration values to calculate expected signal values based on the fit parameters. To do this, call <code>bca( a = conc, return.conc = FALSE )</code>. In this instance, we enter the known concentration values, and tell the function that it is <i>not</i> returning concentration values (it's returning signal values). Because the units of both concentration and signal can vary widely across assays, I intentionally left units off of the example plot.

```{r}
library( ggplot2 )

bca.df <- data.frame( conc = conc,
                      meas = c( rep1, rep2, rep3 ) )

bca.fit.df <- data.frame( conc = conc, 
                          fit = bca( a = conc, return.conc = FALSE ) )

ggplot( bca.df, aes( x = conc, y = meas ) ) +
  geom_point(shape = 21, color = "black", fill = "gray75", size = 2.5) +
  geom_line( data = bca.fit.df, aes( x = conc, y = fit ), color = "red", linewidth = 0.75 ) +
  theme_bw() + 
  theme( axis.text = element_text( size = 14 ),
         axis.title = element_text( size = 16 ) ) +
  labs( x = "Concentration", y = "Signal" )
```
The fit seems reasonable. The observed data points lie nicely along the fitted line. Now that we've calibrated the assay and are fairly confident that the calibration makes sense, we can feed in signal values from samples of unknown concentration. Here, we'll assume that we have five unknown samples and that each unknown sample was measured at a 2-fold dilution. We will use <code>return.conc = TRUE</code> and <code>df = 2</code> in <code>bca()</code> to tell the function that it <i>is</i> returning concentration values and to define the dilution factor(s), respectively. The returned units of concentration are the same as the units of concentration used to make the standard curve.

```{r}
set.seed( 1234 )
unk <- runif(5, min = 0.3, max = 2)

bca( a = unk, return.conc = TRUE, df = 2 )
```

#### Gibson assembly

To calculate Gibson assembly reaction volumes, you need to define seven parameters. These are: insert concentration(s), insert length(s), vector concentration, vector length, the molar ratio of insert to vector, the mass of vector in the reaction (in ng), and the final volume of the reaction <i>before</i> the addition of 2x master mix. To input multiple inserts per reaction, simply enter insert concentration(s) and insert length(s) as a vector. Concentration units should be ng/µL and length units should be bp. Given these parameters, the function <code>gibson()</code> returns a data frame of the volumes (in µL) of each fragment, linearized vector, water, and 2x master mix to add to the reaction.

```{r}
gibson( insert.conc = c( 35, 78 ), insert.len = c( 1800, 2400 ),
        vec.conc = 55, vec.len = 4710, vec.mass = 50,
        molar.ratio = 3, final.vol = 5 )
```

#### Size exclusion column calibration

Size exclusion chromatography (SEC) is a wildly available technique that can provide useful information about macromolecules. Most commonly, SEC is associated with molecular weight. However, SEC actually separates macromolecules according to their hydrodynamic radius (or Stokes radius). For macromolecules with similar overall shapes, changes in hydrodynamic radius are due predominantly to changes in the number of atoms present in the molecule (i.e., its mass). For macromolecules of different shapes, however, separation based on hydrodynamic radius is a poor indicator of molecular weight. For this reason, it is important to be able to calibrate SEC columns for both radius and mass.

The <code>calibrate_sec()</code> function in <code>calibrateR</code> works similarly to the <code>calibrate_colorimetric()</code> function described above. The function minimally requires the user to define three parameters: the measured elution volume of standard analytes, the masses (yes, just the masses; in Da) of standard analytes, and the macromolecular parameter of interest -- either molecular weight (<code>mw</code>) or hydrodynamic radius (<code>rh</code>).

```{r}
masses <- c( 670000, 158000, 44000, 17000, 1350 )
rep1 <- c( 13.36, 16.07, 17.56, 18.46, 20.30 )
rep2 <- c( 13.32, 16.03, 17.49, 18.38, 20.23 )
rep3 <- c( 13.38, 16.09, 17.58, 18.48, 20.33 )
```

```{r}
sec.rh <- calibrate_sec( vols = c( rep1, rep2, rep3 ),
                         masses = masses,
                         parameter = "rh" )
```

Running <code>calibrate_sec()</code> returns a function for downstream number crunching. Setting <code>parameter = "rh"</code> uses a [previously published](https://febs.onlinelibrary.wiley.com/doi/full/10.1046/j.0014-2956.2001.02649.x?sid=nlm%3Apubmed) scaling law to convert the provided mass values to radius values.

Convention for SEC column calibration plots is to plot $\log{(M)}$ or $\log{(R_H)}$ vs. volume. Here, I will create a sequence of dummy elution volumes between the observed elution volumes for the standard analytes. Because I calibrated the column based on hydrodynamic radius instead of mass, I will use the function <code>mass_to_radius()</code> to convert the standard analyte masses to hydrodynamic radii. Then, I will use the calibration to calculate the expected radii of analytes eluting at each of the dummy elution volumes. Non-normalized elution volumes are typically entered in mL units. Because these units don't strictly matter, however, I've left those units off of the plot. The y-axis values are log-transformed. By default, however, the function automatically re-transforms the expected values to the linear scale. Note that the input mass units must be g/mol (Daltons). Calculated mass values are returned in the same units. Hydrodynamic radius values are returned in nm.

```{r}
sec.df <- data.frame( vols = c( rep1, rep2, rep3 ),
                      rads = mass_to_radius( masses = masses ) )

sec.fit <- data.frame( vols = seq( 13, 21, 0.01 ),
                       fit = sec.rh( seq( 13, 21, 0.01 ) ) )

ggplot( sec.df, aes( x = vols, y = log( rads ) ) ) +
  geom_point(shape = 21, color = "black", fill = "gray75", size = 2.5) +
  geom_line( data = sec.fit, aes( x = vols, y = log( fit ) ), color = "red", linewidth = 0.75 ) +
  theme_bw() + 
  theme( axis.text = element_text( size = 14 ),
         axis.title = element_text( size = 16 ) ) +
  labs( x = "Elution Volume", y = "log(Rh)" )
```

To apply the calibrated function to analytes of unknown mass/radius, simply enter the empirical elution volume of the analyte into the function. If the column calibration was done using normalized elution volumes, the function <code>normalize_ev()</code> will normalize the analyte elution volumes based on the column's void and column volumes.

```{r}
sec.rh( 16.495 )
```

### Conclusions

While the functions described above are not the only functions included in <code>calibrateR</code>, they are probably the most widely applicable. Other functions include <code>uv_vis()</code> to calculate macromolecular concentration based on UV/Vis spectroscopy and <code>cfu()</code>, which returns the volume of starter culture to add to a fresh culture of given volume to reach a desired concentration of cells (or CFU)/mL. The plan is incorporate more functionallity into <code>calibrateR</code> over time. As mentioned above, please reach out if you have other ideas/suggestions!
















